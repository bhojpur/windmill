// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// WindmillServiceClient is the client API for WindmillService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WindmillServiceClient interface {
	// StartLocalWindmill starts a Windmill on the Bhojpur.NET Platform directly.
	// The incoming requests are expected in the following order:
	//   1. metadata
	//   2. all bytes constituting the windmill/config.yaml
	//   3. all bytes constituting the Windmill YAML that will be executed (that the config.yaml points to)
	//   4. all bytes constituting the gzipped Bhojpur.NET Platform application tar stream
	//   5. the Bhojpur.NET Platform application tar stream done marker
	StartLocalWindmill(ctx context.Context, opts ...grpc.CallOption) (WindmillService_StartLocalWindmillClient, error)
	// StartFromPreviousWindmill starts a new Windmill based on a previous one.
	// If the previous Windmill does not have the can-replay condition set this call will result in an error.
	StartFromPreviousWindmill(ctx context.Context, in *StartFromPreviousWindmillRequest, opts ...grpc.CallOption) (*StartWindmillResponse, error)
	// StartWindmillRequest starts a new Windmill based on its specification.
	StartWindmill(ctx context.Context, in *StartWindmillRequest, opts ...grpc.CallOption) (*StartWindmillResponse, error)
	// Searches for Windmill(s) known to this Windmill
	ListWindmills(ctx context.Context, in *ListWindmillsRequest, opts ...grpc.CallOption) (*ListWindmillsResponse, error)
	// Subscribe listens to new Windmill(s) updates
	Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (WindmillService_SubscribeClient, error)
	// GetWindmill retrieves details of a single Windmill
	GetWindmill(ctx context.Context, in *GetWindmillRequest, opts ...grpc.CallOption) (*GetWindmillResponse, error)
	// Listen listens to Windmill updates and log output of a running Windmill
	Listen(ctx context.Context, in *ListenRequest, opts ...grpc.CallOption) (WindmillService_ListenClient, error)
	// StopWindmill stops a currently running Windmill
	StopWindmill(ctx context.Context, in *StopWindmillRequest, opts ...grpc.CallOption) (*StopWindmillResponse, error)
}

type windmillServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewWindmillServiceClient(cc grpc.ClientConnInterface) WindmillServiceClient {
	return &windmillServiceClient{cc}
}

func (c *windmillServiceClient) StartLocalWindmill(ctx context.Context, opts ...grpc.CallOption) (WindmillService_StartLocalWindmillClient, error) {
	stream, err := c.cc.NewStream(ctx, &WindmillService_ServiceDesc.Streams[0], "/v1.WindmillService/StartLocalWindmill", opts...)
	if err != nil {
		return nil, err
	}
	x := &windmillServiceStartLocalWindmillClient{stream}
	return x, nil
}

type WindmillService_StartLocalWindmillClient interface {
	Send(*StartLocalWindmillRequest) error
	CloseAndRecv() (*StartWindmillResponse, error)
	grpc.ClientStream
}

type windmillServiceStartLocalWindmillClient struct {
	grpc.ClientStream
}

func (x *windmillServiceStartLocalWindmillClient) Send(m *StartLocalWindmillRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *windmillServiceStartLocalWindmillClient) CloseAndRecv() (*StartWindmillResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(StartWindmillResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *windmillServiceClient) StartFromPreviousWindmill(ctx context.Context, in *StartFromPreviousWindmillRequest, opts ...grpc.CallOption) (*StartWindmillResponse, error) {
	out := new(StartWindmillResponse)
	err := c.cc.Invoke(ctx, "/v1.WindmillService/StartFromPreviousWindmill", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *windmillServiceClient) StartWindmill(ctx context.Context, in *StartWindmillRequest, opts ...grpc.CallOption) (*StartWindmillResponse, error) {
	out := new(StartWindmillResponse)
	err := c.cc.Invoke(ctx, "/v1.WindmillService/StartWindmill", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *windmillServiceClient) ListWindmills(ctx context.Context, in *ListWindmillsRequest, opts ...grpc.CallOption) (*ListWindmillsResponse, error) {
	out := new(ListWindmillsResponse)
	err := c.cc.Invoke(ctx, "/v1.WindmillService/ListWindmills", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *windmillServiceClient) Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (WindmillService_SubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &WindmillService_ServiceDesc.Streams[1], "/v1.WindmillService/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &windmillServiceSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type WindmillService_SubscribeClient interface {
	Recv() (*SubscribeResponse, error)
	grpc.ClientStream
}

type windmillServiceSubscribeClient struct {
	grpc.ClientStream
}

func (x *windmillServiceSubscribeClient) Recv() (*SubscribeResponse, error) {
	m := new(SubscribeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *windmillServiceClient) GetWindmill(ctx context.Context, in *GetWindmillRequest, opts ...grpc.CallOption) (*GetWindmillResponse, error) {
	out := new(GetWindmillResponse)
	err := c.cc.Invoke(ctx, "/v1.WindmillService/GetWindmill", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *windmillServiceClient) Listen(ctx context.Context, in *ListenRequest, opts ...grpc.CallOption) (WindmillService_ListenClient, error) {
	stream, err := c.cc.NewStream(ctx, &WindmillService_ServiceDesc.Streams[2], "/v1.WindmillService/Listen", opts...)
	if err != nil {
		return nil, err
	}
	x := &windmillServiceListenClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type WindmillService_ListenClient interface {
	Recv() (*ListenResponse, error)
	grpc.ClientStream
}

type windmillServiceListenClient struct {
	grpc.ClientStream
}

func (x *windmillServiceListenClient) Recv() (*ListenResponse, error) {
	m := new(ListenResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *windmillServiceClient) StopWindmill(ctx context.Context, in *StopWindmillRequest, opts ...grpc.CallOption) (*StopWindmillResponse, error) {
	out := new(StopWindmillResponse)
	err := c.cc.Invoke(ctx, "/v1.WindmillService/StopWindmill", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WindmillServiceServer is the server API for WindmillService service.
// All implementations must embed UnimplementedWindmillServiceServer
// for forward compatibility
type WindmillServiceServer interface {
	// StartLocalWindmill starts a Windmill on the Bhojpur.NET Platform directly.
	// The incoming requests are expected in the following order:
	//   1. metadata
	//   2. all bytes constituting the windmill/config.yaml
	//   3. all bytes constituting the Windmill YAML that will be executed (that the config.yaml points to)
	//   4. all bytes constituting the gzipped Bhojpur.NET Platform application tar stream
	//   5. the Bhojpur.NET Platform application tar stream done marker
	StartLocalWindmill(WindmillService_StartLocalWindmillServer) error
	// StartFromPreviousWindmill starts a new Windmill based on a previous one.
	// If the previous Windmill does not have the can-replay condition set this call will result in an error.
	StartFromPreviousWindmill(context.Context, *StartFromPreviousWindmillRequest) (*StartWindmillResponse, error)
	// StartWindmillRequest starts a new Windmill based on its specification.
	StartWindmill(context.Context, *StartWindmillRequest) (*StartWindmillResponse, error)
	// Searches for Windmill(s) known to this Windmill
	ListWindmills(context.Context, *ListWindmillsRequest) (*ListWindmillsResponse, error)
	// Subscribe listens to new Windmill(s) updates
	Subscribe(*SubscribeRequest, WindmillService_SubscribeServer) error
	// GetWindmill retrieves details of a single Windmill
	GetWindmill(context.Context, *GetWindmillRequest) (*GetWindmillResponse, error)
	// Listen listens to Windmill updates and log output of a running Windmill
	Listen(*ListenRequest, WindmillService_ListenServer) error
	// StopWindmill stops a currently running Windmill
	StopWindmill(context.Context, *StopWindmillRequest) (*StopWindmillResponse, error)
	mustEmbedUnimplementedWindmillServiceServer()
}

// UnimplementedWindmillServiceServer must be embedded to have forward compatible implementations.
type UnimplementedWindmillServiceServer struct {
}

func (UnimplementedWindmillServiceServer) StartLocalWindmill(WindmillService_StartLocalWindmillServer) error {
	return status.Errorf(codes.Unimplemented, "method StartLocalWindmill not implemented")
}
func (UnimplementedWindmillServiceServer) StartFromPreviousWindmill(context.Context, *StartFromPreviousWindmillRequest) (*StartWindmillResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartFromPreviousWindmill not implemented")
}
func (UnimplementedWindmillServiceServer) StartWindmill(context.Context, *StartWindmillRequest) (*StartWindmillResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartWindmill not implemented")
}
func (UnimplementedWindmillServiceServer) ListWindmills(context.Context, *ListWindmillsRequest) (*ListWindmillsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListWindmills not implemented")
}
func (UnimplementedWindmillServiceServer) Subscribe(*SubscribeRequest, WindmillService_SubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedWindmillServiceServer) GetWindmill(context.Context, *GetWindmillRequest) (*GetWindmillResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWindmill not implemented")
}
func (UnimplementedWindmillServiceServer) Listen(*ListenRequest, WindmillService_ListenServer) error {
	return status.Errorf(codes.Unimplemented, "method Listen not implemented")
}
func (UnimplementedWindmillServiceServer) StopWindmill(context.Context, *StopWindmillRequest) (*StopWindmillResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopWindmill not implemented")
}
func (UnimplementedWindmillServiceServer) mustEmbedUnimplementedWindmillServiceServer() {}

// UnsafeWindmillServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WindmillServiceServer will
// result in compilation errors.
type UnsafeWindmillServiceServer interface {
	mustEmbedUnimplementedWindmillServiceServer()
}

func RegisterWindmillServiceServer(s grpc.ServiceRegistrar, srv WindmillServiceServer) {
	s.RegisterService(&WindmillService_ServiceDesc, srv)
}

func _WindmillService_StartLocalWindmill_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(WindmillServiceServer).StartLocalWindmill(&windmillServiceStartLocalWindmillServer{stream})
}

type WindmillService_StartLocalWindmillServer interface {
	SendAndClose(*StartWindmillResponse) error
	Recv() (*StartLocalWindmillRequest, error)
	grpc.ServerStream
}

type windmillServiceStartLocalWindmillServer struct {
	grpc.ServerStream
}

func (x *windmillServiceStartLocalWindmillServer) SendAndClose(m *StartWindmillResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *windmillServiceStartLocalWindmillServer) Recv() (*StartLocalWindmillRequest, error) {
	m := new(StartLocalWindmillRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _WindmillService_StartFromPreviousWindmill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartFromPreviousWindmillRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WindmillServiceServer).StartFromPreviousWindmill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.WindmillService/StartFromPreviousWindmill",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WindmillServiceServer).StartFromPreviousWindmill(ctx, req.(*StartFromPreviousWindmillRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WindmillService_StartWindmill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartWindmillRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WindmillServiceServer).StartWindmill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.WindmillService/StartWindmill",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WindmillServiceServer).StartWindmill(ctx, req.(*StartWindmillRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WindmillService_ListWindmills_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListWindmillsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WindmillServiceServer).ListWindmills(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.WindmillService/ListWindmills",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WindmillServiceServer).ListWindmills(ctx, req.(*ListWindmillsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WindmillService_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WindmillServiceServer).Subscribe(m, &windmillServiceSubscribeServer{stream})
}

type WindmillService_SubscribeServer interface {
	Send(*SubscribeResponse) error
	grpc.ServerStream
}

type windmillServiceSubscribeServer struct {
	grpc.ServerStream
}

func (x *windmillServiceSubscribeServer) Send(m *SubscribeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _WindmillService_GetWindmill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWindmillRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WindmillServiceServer).GetWindmill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.WindmillService/GetWindmill",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WindmillServiceServer).GetWindmill(ctx, req.(*GetWindmillRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WindmillService_Listen_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListenRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WindmillServiceServer).Listen(m, &windmillServiceListenServer{stream})
}

type WindmillService_ListenServer interface {
	Send(*ListenResponse) error
	grpc.ServerStream
}

type windmillServiceListenServer struct {
	grpc.ServerStream
}

func (x *windmillServiceListenServer) Send(m *ListenResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _WindmillService_StopWindmill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopWindmillRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WindmillServiceServer).StopWindmill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.WindmillService/StopWindmill",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WindmillServiceServer).StopWindmill(ctx, req.(*StopWindmillRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// WindmillService_ServiceDesc is the grpc.ServiceDesc for WindmillService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WindmillService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "v1.WindmillService",
	HandlerType: (*WindmillServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartFromPreviousWindmill",
			Handler:    _WindmillService_StartFromPreviousWindmill_Handler,
		},
		{
			MethodName: "StartWindmill",
			Handler:    _WindmillService_StartWindmill_Handler,
		},
		{
			MethodName: "ListWindmills",
			Handler:    _WindmillService_ListWindmills_Handler,
		},
		{
			MethodName: "GetWindmill",
			Handler:    _WindmillService_GetWindmill_Handler,
		},
		{
			MethodName: "StopWindmill",
			Handler:    _WindmillService_StopWindmill_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StartLocalWindmill",
			Handler:       _WindmillService_StartLocalWindmill_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Subscribe",
			Handler:       _WindmillService_Subscribe_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Listen",
			Handler:       _WindmillService_Listen_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "windmill.proto",
}
